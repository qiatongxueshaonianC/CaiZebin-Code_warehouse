#include<bits/stdc++.h>
using namespace std;
struct Node{
	int x,y;
	Node(int a,int b):x(a),y(b){}
};
int n,step,t;
vector<Node> stone;
bool flag,vis[9][9];
vector<pair<int,int> >XY={{-1,0},{0,1},{-1,1},{1,0},{1,1},{0,0},{1,-1},{0,-1},{-1,-1}};
//天啊，改变一下优先行进方向就可以了！！！！！不然死活过不了，进入死循环 
bool judge(int x,int y){
	if(x<0||x>=8||y<0||y>=8) return false;
	if(vis[x][y]==true) return false;
	for(auto i:stone){
		if((x==i.x&&y==i.y)||(x==i.x+1&&y==i.y)) return false;
	}
	return true;
}
void DFS(int x,int y){
	if(x==0&&y==7){
		flag=true;
		return;
	}
//	vis[x][y]=true;            //加了vis后结果不对，不加运行不出结果 ，对于能到达的情况 
	for(int i=0;i<9;i++){
		if(flag==true) return;
		int newx=x+XY[i].first;
		int newy=y+XY[i].second;
		if(judge(newx,newy)){  //剪枝 
			for(auto&i:stone)
				i.x=i.x+1; 
			DFS(newx,newy);
			for(auto&i:stone)
				i.x--;
		}
	}
//	vis[x][y]=false;
}
int main() {
	scanf("%d%*c",&n);
	int pos,k;
	for(t=1;t<=n;t++){
		for(int i=0;i<8;i++){
			pos=k=0;
			string s1;
			cin>>s1;
			while(1){
				pos=s1.find('S',k);
				if(pos==string::npos) break;
				Node node(i,pos);
				stone.push_back(node);
				k=pos+1;
			}
		}
		DFS(7,0);
		if(flag==true){
			cout<<"Case #"<<t<<": "<<"Yes"<<endl;
		}else cout<<"Case #"<<t<<": "<<"No"<<endl;
		stone.clear();
		flag=false;
		memset(vis,false,sizeof(vis)); 
	}
	return 0;
}
/*
5
.......A
........
........
........
........
........
........
U.......

.......A
........
........
........
........
.S......
S.......
US......

.......A
........
........
........
........
........
SS......
US......

.......A
........
........
........
........
.S......
S.......
U.......

.......A
........
........
........
........
.S......
S.......
U.S.....
*/